/*
 * The MIT License (MIT)
 * Copyright (c) 2012 William Woodall <wjwwood@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 */

#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cfloat>
#include <algorithm>
#include <string>

#include <ros/ros.h>
#include <tf/tf.h>

#ifdef WIN32
#ifdef DELETE
// ach, windows.h polluting everything again,
// clashes with autogenerated visualization_msgs/Marker.h
#undef DELETE
#endif
#endif
#include "nav_msgs/Odometry.h"
#include "sensor_msgs/NavSatFix.h"
#include "sensor_msgs/Imu.h"
#include "geometry_msgs/Quaternion.h"
#include "gps_msgs/Ephemeris.h"
#include "gps_msgs/L1L2Range.h"

#include <boost/tokenizer.hpp>
#include <boost/thread/thread.hpp>

#include <tf/transform_broadcaster.h>

#include "novatel/novatel.h"
using namespace novatel;

// Logging system message handlers
void handleInfoMessages(const std::string &msg) {
	ROS_INFO("%s", msg.c_str());
}
void handleWarningMessages(const std::string &msg) {
	ROS_WARN("%s", msg.c_str());
}
void handleErrorMessages(const std::string &msg) {
	ROS_ERROR("%s", msg.c_str());
}
void handleDebugMessages(const std::string &msg) {
	ROS_DEBUG("%s", msg.c_str());
}

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
static double radians_to_degrees = 180.0 / M_PI;
static double degrees_to_radians = M_PI / 180.0;
static double degrees_square_to_radians_square = degrees_to_radians
		* degrees_to_radians;

static double sigma_v = 0.05; // velocity std dev in m/s

// ROS Node class
class NovatelNode {
public:
	NovatelNode() :
		nh_("~") {

		// set up logging handlers
		gps_.setLogInfoCallback(handleInfoMessages);
		gps_.setLogWarningCallback(handleWarningMessages);
		gps_.setLogErrorCallback(handleErrorMessages);
		gps_.setLogDebugCallback(handleDebugMessages);

		gps_.set_best_position_callback(boost::bind(&NovatelNode::BestPOSHandler, this, _1, _2));

		gps_.set_best_gps_position_callback(boost::bind(&NovatelNode::BESTGNSSPosHandler, this, _1, _2));

		gps_.set_best_velocity_callback(boost::bind(&NovatelNode::BestVelocityHandler, this, _1, _2));
		//gps_.set_best_position_ecef_callback(boost::bind(&NovatelNode::BestPositionEcefHandler, this, _1,_2));
		gps_.set_best_utm_position_callback(boost::bind(&NovatelNode::BestUtmHandler, this, _1, _2));
		//gps_.set_raw_imu_short_callback(boost::bind(&NovatelNode::RawImuHandler, this, _1, _2));

		// gps_.set_receiver_hardware_status_callback(boost::bind(&NovatelNode::HardwareStatusHandler, this, _1, _2));
		gps_.set_gps_ephemeris_callback(boost::bind(&NovatelNode::EphemerisHandler, this, _1, _2));
		gps_.set_compressed_range_measurements_callback(boost::bind(&NovatelNode::CompressedRangeHandler, this, _1, _2));
		// gps_.set_raw_msg_callback(boost::bind(&NovatelNode::RawMsgHandler, this, _1));
		gps_.set_best_pseudorange_position_callback(boost::bind(&NovatelNode::PsrPosHandler, this, _1, _2));
		gps_.set_best_lever_arm_callback(boost::bind(&NovatelNode::BestLeverArmHandler, this, _1, _2));

		gps_.set_corr_imu_callback(boost::bind(&NovatelNode::CorrImuHandler, this, _1, _2));
		gps_.set_ins_position_velocity_attitude_callback(boost::bind(&NovatelNode::InsPvaHandler, this, _1, _2));
		gps_.set_ins_covariance_callback(boost::bind(&NovatelNode::InsCovHandler, this, _1, _2));

	}

	~NovatelNode() {
		this->disconnect();
	}

	inline double psi2theta(double psi) {
		return M_PI / 2 - psi;
	}
	inline double theta2psi(double theta) {
		return M_PI / 2 - theta;
	}

	// TB: The BESTPOS sentence is used together with BESTVEL sentence.
	// However, the information are embedded in odom sentence without
	// checking GPS milliseconds as BESTPOS always lag by 1/Fs.
	void BestPOSHandler(Position &best_position, double &time_stamp){
		double northing, easting;
		int zoneNum;
		bool north;

		cur_bestpos_ = best_position;
		sensor_msgs::NavSatFix sat_fix;
		sat_fix.header.stamp = ros::Time::now();
		sat_fix.header.frame_id = "best";

		switch(best_position.position_type){
		case SINGLE:
			ROS_INFO_ONCE("BESTPOS: Position Type is SINGLE.");
			break;
		case PSRDIFF:
			ROS_INFO_ONCE("BESTPOS: Position Type is PSRDIFF.");
			break;
		case NARROW_FLOAT:
			ROS_INFO_ONCE("BESTPOS: Position Type is NARROW_FLOAT.");
			break;
		case L1_INT:
			ROS_INFO_ONCE("BESTPOS: Position Type is L1_INT.");
			break;
		case WIDE_INT:
			ROS_INFO_ONCE("BESTPOS: Position Type is WIDE_INT.");
			break;
		case NARROW_INT:
			ROS_INFO_ONCE("BESTPOS: Position Type is NARROW_INT.");
			break;
		case RTK_DIRECT_INS:
			ROS_INFO_ONCE("BESTPOS: Position Type is RTK_DIRECT_INS.");
			break;
		case INS_PSRDIFF:
			ROS_INFO_ONCE("BESTPOS: Position Type is INS_PSRDIFF.");
			break;
		case INS_RTKFLOAT:
			ROS_INFO_ONCE("BESTPOS: Position Type is INS_RTKFLOAT.");
			break;
		case INS_RTKFIXED:
			ROS_INFO_ONCE("BESTPOS: Position Type is INS_RTKFIXED.");
			break;
		default:
			ROS_INFO_ONCE("BESTPOS: Position Type is UNKNOWN.");
			break;
		}


		if (best_position.position_type == NONE)
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_NO_FIX;
		else if ((best_position.position_type == WAAS) ||
				(best_position.position_type == OMNISTAR) ||
				(best_position.position_type == OMNISTAR_HP) ||
				(best_position.position_type == OMNISTAR_XP) ||
				(best_position.position_type == CDGPS))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_SBAS_FIX;
		else if ((best_position.position_type == PSRDIFF) ||
				(best_position.position_type == NARROW_FLOAT) ||
				(best_position.position_type == WIDE_INT) ||
				(best_position.position_type == WIDE_INT) ||
				(best_position.position_type == NARROW_INT) ||
				(best_position.position_type == RTK_DIRECT_INS) ||
				(best_position.position_type == INS_PSRDIFF) ||
				(best_position.position_type == INS_RTKFLOAT) ||
				(best_position.position_type == INS_RTKFIXED))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_GBAS_FIX;
		else
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_FIX;

		if (best_position.signals_used_mask & 0x30)
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GLONASS;
		else
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GPS;

		sat_fix.position_covariance_type = sensor_msgs::NavSatFix::COVARIANCE_TYPE_KNOWN;

		sat_fix.latitude = best_position.latitude;
		sat_fix.longitude = best_position.longitude;
		sat_fix.altitude = best_position.height;

		sat_fix.position_covariance[0] = pow(best_position.latitude_standard_deviation, 2);
		sat_fix.position_covariance[4] = pow(best_position.longitude_standard_deviation, 2);
		sat_fix.position_covariance[8] = pow(best_position.height_standard_deviation, 2);
		/* TB: For debugging purposes */
		sat_fix.position_covariance[1] = best_position.differential_age;
		sat_fix.position_covariance[2] = best_position.solution_age;
		sat_fix.position_covariance[3] = best_position.position_type;
		sat_fix.position_covariance[5] = best_position.number_of_satellites;

		bestpos_publisher_.publish(sat_fix);

		// This odometry sentences is to be used by EKF localization node for speed and track heading.
		nav_msgs::Odometry cur_odom_;
		cur_odom_.header.stamp = ros::Time::now();
		cur_odom_.header.frame_id = "odom";
		cur_odom_.child_frame_id = "base_link";

		// This is then used to create an odometry sentence.
		gps_.ConvertLLaUTM(best_position.latitude, best_position.longitude, &northing,
				&easting, &zoneNum, &north);

		cur_odom_.pose.pose.position.x = easting;
		cur_odom_.pose.pose.position.y = northing;
		cur_odom_.pose.pose.position.z = best_position.height;
		// covariance representation given in REP 103
		//http://www.ros.org/reps/rep-0103.html#covariance-representation
		// (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
		// row major
		// have no way of knowing roll and pitch with just GPS
		cur_odom_.pose.covariance[21] = DBL_MAX;
		cur_odom_.pose.covariance[28] = DBL_MAX;

		/* TB: Notice that the BESTPOS outputs lat, long and height covariances.
		 * so, here just these values are repeated. To get true covariances from BESTPOS,
		 * use sat fix sentence. */
		cur_odom_.pose.covariance[0] = pow(best_position.latitude_standard_deviation, 2);
		cur_odom_.pose.covariance[7] = pow(best_position.longitude_standard_deviation, 2);
		cur_odom_.pose.covariance[14] = pow(best_position.height_standard_deviation, 2);
		// have no way of knowing roll and pitch with just GPS
		cur_odom_.pose.covariance[21] = DBL_MAX;
		cur_odom_.pose.covariance[28] = DBL_MAX;
		/* TB: add critical information in this topic for debugging -- */
		cur_odom_.pose.covariance[15] = best_position.solution_status;
		cur_odom_.pose.covariance[16] = best_position.position_type;
		cur_odom_.pose.covariance[17] = best_position.undulation;
		cur_odom_.pose.covariance[18] = best_position.datum_id;
		cur_odom_.pose.covariance[19] = best_position.base_station_id[0];
		cur_odom_.pose.covariance[20] = best_position.base_station_id[1];
		cur_odom_.pose.covariance[22] = best_position.base_station_id[2];
		cur_odom_.pose.covariance[23] = best_position.base_station_id[3];
		cur_odom_.pose.covariance[24] = best_position.differential_age;
		cur_odom_.pose.covariance[25] = best_position.solution_age;
		cur_odom_.pose.covariance[26] = best_position.number_of_satellites;
		cur_odom_.pose.covariance[27] = best_position.number_of_satellites_in_solution;
		cur_odom_.pose.covariance[29] = best_position.extended_solution_status;

		/*TB: Do not need to check the GPS time stamps in BESTPOS and BESTVEL*/
		cur_odom_.twist.twist.linear.x = cur_velocity_.horizontal_speed*sin(cur_velocity_.track_over_ground * degrees_to_radians);
		cur_odom_.twist.twist.linear.y = cur_velocity_.horizontal_speed*cos(cur_velocity_.track_over_ground * degrees_to_radians);
		cur_odom_.twist.twist.linear.z = cur_velocity_.vertical_speed;

		cur_odom_.pose.pose.orientation = tf::createQuaternionMsgFromYaw(
				psi2theta(cur_velocity_.track_over_ground*degrees_to_radians));

		// if i have a fix, velocity std, dev is constant
		if (cur_velocity_.position_type > NONE)
		{
			// yaw covariance
			double heading_std_dev = sigma_v / cur_velocity_.horizontal_speed;
			cur_odom_.pose.covariance[35] = heading_std_dev * heading_std_dev;
			// x and y velocity covariance
			cur_odom_.twist.covariance[0] = sigma_v * sigma_v;
			cur_odom_.twist.covariance[7] = sigma_v * sigma_v;
		}
		else
		{
			cur_odom_.pose.covariance[35] = DBL_MAX;
			cur_odom_.twist.covariance[0] = DBL_MAX;
			cur_odom_.twist.covariance[7] = DBL_MAX;
		}

		odom_base_publisher_.publish(cur_odom_);
	}

	// Best UTM handler is to be used in pair with BESTVEL sentence.
	void BestUtmHandler(UtmPosition &pos, double &timestamp) {
		ROS_DEBUG("Received BestUtm");
		cur_utm_bestpos_ = pos;

		//got_bestutm = true;
		static double course_track = 0.0;
		double latitude, longitude;

		switch(pos.position_type){
		case SINGLE:
			ROS_INFO_ONCE("BESTUTM: Position Type is SINGLE.");
			break;
		case PSRDIFF:
			ROS_INFO_ONCE("BESTUTM: Position Type is PSRDIFF.");
			break;
		case NARROW_FLOAT:
			ROS_INFO_ONCE("BESTUTM: Position Type is NARROW_FLOAT.");
			break;
		case L1_INT:
			ROS_INFO_ONCE("BESTUTM: Position Type is L1_INT.");
			break;
		case WIDE_INT:
			ROS_INFO_ONCE("BESTUTM: Position Type is WIDE_INT.");
			break;
		case NARROW_INT:
			ROS_INFO_ONCE("BESTUTM: Position Type is NARROW_INT.");
			break;
		case RTK_DIRECT_INS:
			ROS_INFO_ONCE("BESTUTM: Position Type is RTK_DIRECT_INS.");
			break;
		case INS_PSRDIFF:
			ROS_INFO_ONCE("BESTUTM: Position Type is INS_PSRDIFF.");
			break;
		case INS_RTKFLOAT:
			ROS_INFO_ONCE("BESTUTM: Position Type is INS_RTKFLOAT.");
			break;
		case INS_RTKFIXED:
			ROS_INFO_ONCE("BESTUTM: Position Type is INS_RTKFIXED.");
			break;
		default:
			ROS_INFO_ONCE("BESTUTM: Position Type is UNKNOWN.");
			break;
		}

		/* The North is set to true for Finland, but needs to implement it according to latitudinal zone letter. */
		gps_.ConvertUTMLLA(pos.northing, pos.easting, pos.longitude_zone_number, true, &latitude,
				&longitude);

		sensor_msgs::NavSatFix sat_fix;
		sat_fix.header.stamp = ros::Time::now();
		sat_fix.header.frame_id = "best";

		if (pos.position_type == NONE)
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_NO_FIX;
		else if ((pos.position_type == WAAS) || (pos.position_type == OMNISTAR)
				|| (pos.position_type == OMNISTAR_HP)
				|| (pos.position_type == OMNISTAR_XP)
				|| (pos.position_type == CDGPS))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_SBAS_FIX;
		else if ((pos.position_type == PSRDIFF)
				|| (pos.position_type == NARROW_FLOAT)
				|| (pos.position_type == WIDE_INT)
				|| (pos.position_type == WIDE_INT)
				|| (pos.position_type == NARROW_INT)
				|| (pos.position_type == RTK_DIRECT_INS)
				|| (pos.position_type == INS_PSRDIFF)
				|| (pos.position_type == INS_RTKFLOAT)
				|| (pos.position_type == INS_RTKFIXED))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_GBAS_FIX;
		else
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_FIX;

		if (pos.signals_used_mask & 0x30)
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GLONASS;
		else
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GPS;

		sat_fix.position_covariance_type = sensor_msgs::NavSatFix::COVARIANCE_TYPE_KNOWN;

		sat_fix.latitude = latitude*radians_to_degrees;
		sat_fix.longitude = longitude*radians_to_degrees;
		sat_fix.altitude = pos.height;

		/*TB: Here the lat, and long at not available in BESTUTM sentence, so just
		 * put the covariances of easting and northing here */
		sat_fix.position_covariance[0] = pow(pos.easting_standard_deviation, 2);
		sat_fix.position_covariance[4] = pow(pos.northing_standard_deviation, 2);
		sat_fix.position_covariance[8] = pow(pos.height_standard_deviation, 2);
		/* TB: For debugging purposes */
		sat_fix.position_covariance[1] = pos.differential_age;
		sat_fix.position_covariance[2] = pos.solution_age;
		sat_fix.position_covariance[3] = pos.position_type;
		sat_fix.position_covariance[5] = pos.number_of_satellites;

		bestpos_publisher_.publish(sat_fix);

		// This sentences is to be used by EKF localization node for speed and track heading.
		nav_msgs::Odometry cur_odom_;
		cur_odom_.header.stamp = ros::Time::now();
		cur_odom_.header.frame_id = "odom";
		cur_odom_.child_frame_id = "base_link";

		cur_odom_.pose.pose.position.x = pos.easting;
		cur_odom_.pose.pose.position.y = pos.northing;
		cur_odom_.pose.pose.position.z = pos.height;
		// covariance representation given in REP 103
		//http://www.ros.org/reps/rep-0103.html#covariance-representation
		// (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
		// row major
		cur_odom_.pose.covariance[0] = pos.easting_standard_deviation*pos.easting_standard_deviation;
		cur_odom_.pose.covariance[7] = pos.northing_standard_deviation*pos.northing_standard_deviation;
		cur_odom_.pose.covariance[14] = pos.height_standard_deviation*pos.height_standard_deviation;
		// have no way of knowing roll and pitch with just GPS
		cur_odom_.pose.covariance[21] = DBL_MAX;
		cur_odom_.pose.covariance[28] = DBL_MAX;
		// embed lever arms information in this sentence
		/* TB: add critical information in this topic for debugging -- */
		cur_odom_.pose.covariance[15] = pos.solution_status;
		cur_odom_.pose.covariance[16] = pos.position_type;
		cur_odom_.pose.covariance[17] = pos.undulation;
		cur_odom_.pose.covariance[18] = pos.datum_id;
		cur_odom_.pose.covariance[19] = pos.base_station_id[0];
		cur_odom_.pose.covariance[20] = pos.base_station_id[1];
		cur_odom_.pose.covariance[22] = pos.base_station_id[2];
		cur_odom_.pose.covariance[23] = pos.base_station_id[3];
		cur_odom_.pose.covariance[24] = pos.differential_age;
		cur_odom_.pose.covariance[25] = pos.solution_age;
		cur_odom_.pose.covariance[26] = pos.number_of_satellites;
		cur_odom_.pose.covariance[27] = pos.number_of_satellites_in_solution;
		cur_odom_.pose.covariance[29] = pos.extended_solution_status;


		/*TB: Do not need to check the GPS time stamps in BESTPOS and BESTVEL*/
		/*if ((cur_velocity_.header.gps_week == pos.header.gps_week)
				&& (cur_velocity_.header.gps_millisecs
						== pos.header.gps_millisecs))*/
		{
			//ROS_INFO_ONCE("BESTVEL FUSED WITH BESTUTM.");
			cur_odom_.twist.twist.linear.x = cur_velocity_.horizontal_speed*sin(cur_velocity_.track_over_ground * degrees_to_radians);
			cur_odom_.twist.twist.linear.y = cur_velocity_.horizontal_speed*cos(cur_velocity_.track_over_ground * degrees_to_radians);
			cur_odom_.twist.twist.linear.z = cur_velocity_.vertical_speed;
//cur_odom_.twist.twist.angular.x == roll rate
			cur_odom_.pose.pose.orientation = tf::createQuaternionMsgFromYaw(
					psi2theta(cur_velocity_.track_over_ground*degrees_to_radians));

			// if i have a fix, velocity std, dev is constant
			if (cur_velocity_.position_type > NONE)
			{
				// yaw covariance
				double heading_std_dev = sigma_v / cur_velocity_.horizontal_speed;
				cur_odom_.pose.covariance[35] = heading_std_dev * heading_std_dev;
				// x and y velocity covariance
				cur_odom_.twist.covariance[0] = sigma_v * sigma_v;
				cur_odom_.twist.covariance[7] = sigma_v * sigma_v;
			}
			else
			{
				cur_odom_.pose.covariance[35] = DBL_MAX;
				cur_odom_.twist.covariance[0] = DBL_MAX;
				cur_odom_.twist.covariance[7] = DBL_MAX;
			}
		}
		odom_base_publisher_.publish(cur_odom_);
	}

	void BestVelocityHandler(Velocity &vel, double &timestamp) {
		ROS_INFO_ONCE("Received BESTVEL.");
		cur_velocity_ = vel;
	}

	void InsPvaHandler(InsPositionVelocityAttitude &ins_pva,
			double &timestamp) {
		ROS_INFO_ONCE("Received INSPVA.");
		// con	Insert pva position to UTM
		double northing, easting;

		int zoneNum;
		bool north;
		static double span_scale_factor = 125.0; // For Span-IGM-S1
		static int set_init_datum = 1;
		static int count = 0;

		cur_inspva_ = ins_pva;
		switch(ins_pva.status){
		case INS_SOLUTION_GOOD:
			ROS_INFO_ONCE("INS SOLUTION GOOD.");
			break;
		case INS_ALIGNING:
			ROS_INFO_ONCE("INS ALIGNING.");
			break;
		case INS_SOLUTION_NOT_GOOD:
			ROS_INFO_ONCE("INS SOLUTION NOT GOOD.");
			break;
		case INS_ALIGNMENT_COMPLETE:
			ROS_INFO_ONCE("INS ALIGNMENT COMPLETE.");
			break;
		default:
			ROS_INFO_ONCE("INS SOLUTION UNKNOWN.");
			break;
		}

		sensor_msgs::NavSatFix sat_fix;
		sat_fix.header.stamp = ros::Time::now();
		sat_fix.header.frame_id = "ins";

		if (ins_pva.status == INS_SOLUTION_GOOD)
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_FIX;
		else
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_NO_FIX;

		sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GPS;

		sat_fix.latitude = ins_pva.latitude;
		sat_fix.longitude = ins_pva.longitude;
		sat_fix.altitude = ins_pva.height; // the ellipsoidal height is reported here.

		sat_fix.position_covariance_type = sensor_msgs::NavSatFix::COVARIANCE_TYPE_DIAGONAL_KNOWN;
		/*Add covariance values from INSCOV sentence. */
		sat_fix.position_covariance[0] = cur_ins_cov_.position_covariance[0];
		sat_fix.position_covariance[4] = cur_ins_cov_.position_covariance[4];
		sat_fix.position_covariance[8] = cur_ins_cov_.position_covariance[8];
		/*TB: For debugging purposes */
		sat_fix.position_covariance[1] = ins_pva.roll;
		sat_fix.position_covariance[2] = ins_pva.pitch;
		sat_fix.position_covariance[3] = ins_pva.azimuth;
		sat_fix.position_covariance[5] = ins_pva.status;

		nav_sat_fix_publisher_.publish(sat_fix);

		// Convert to "East, North, Up" orientation
		geometry_msgs::Quaternion enu_orientation =
				tf::createQuaternionMsgFromRollPitchYaw(
						ins_pva.roll * degrees_to_radians,
						-ins_pva.pitch * degrees_to_radians,
						psi2theta(ins_pva.azimuth * degrees_to_radians));
		/*-1.0*ins_pva.azimuth * degrees_to_radians);*/
		/* The Odometry data is created here which is based on the Novatel's internal EKF Filters. */
		nav_msgs::Odometry cur_odom_;
		cur_odom_.header.stamp = ros::Time::now();//sat_fix.header.stamp;
		/* Create the topic to get map to base_link. */
		cur_odom_.header.frame_id = "map";
		cur_odom_.child_frame_id = "base_link";

		// This is then used to create an odometry sentence.
		gps_.ConvertLLaUTM(ins_pva.latitude, ins_pva.longitude, &northing,
				&easting, &zoneNum, &north);

		/* In this sentence the position in LLA format is logged, must be changed to UTM if
		 * the ROS functionality is to be used.*/
		cur_odom_.pose.pose.position.x = easting;
		cur_odom_.pose.pose.position.y = northing;
		cur_odom_.pose.pose.position.z = ins_pva.height;

		/*Similarly for logging purposes the RPY angles are sent in INSPVA log
		 * instead of Quaternion. */
		cur_odom_.pose.pose.orientation = enu_orientation;

		/*cur_odom_.pose.pose.orientation.x = ins_pva.roll * degrees_to_radians;
		cur_odom_.pose.pose.orientation.y = ins_pva.pitch * degrees_to_radians;
		cur_odom_.pose.pose.orientation.z = ins_pva.azimuth;
		cur_odom_.pose.pose.orientation.w = 0.0;*/

		/* Velocities are expressed in body frame. x is forward, y is sideways, z points up. */
		cur_odom_.twist.twist.linear.x = ins_pva.east_velocity;
		cur_odom_.twist.twist.linear.y = ins_pva.north_velocity;
		cur_odom_.twist.twist.linear.z = ins_pva.up_velocity;

		// see if there is a matching ins covariance message
		/*if ((cur_ins_cov_.gps_week==ins_pva.gps_week)
				&& (cur_ins_cov_.gps_millisecs==ins_pva.gps_millisecs)) {*/
			ROS_INFO_ONCE("COVARIANCES FUSED WITH INSPVA.");

			cur_odom_.pose.covariance[0] = cur_ins_cov_.position_covariance[0];
			cur_odom_.pose.covariance[1] = cur_ins_cov_.position_covariance[1];
			cur_odom_.pose.covariance[2] = cur_ins_cov_.position_covariance[2];
			cur_odom_.pose.covariance[6] = cur_ins_cov_.position_covariance[3];
			cur_odom_.pose.covariance[7] = cur_ins_cov_.position_covariance[4];
			cur_odom_.pose.covariance[8] = cur_ins_cov_.position_covariance[5];
			cur_odom_.pose.covariance[12] = cur_ins_cov_.position_covariance[6];
			cur_odom_.pose.covariance[13] = cur_ins_cov_.position_covariance[7];
			cur_odom_.pose.covariance[14] = cur_ins_cov_.position_covariance[8];

			cur_odom_.pose.covariance[21] = cur_ins_cov_.attitude_covariance[0]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[22] = cur_ins_cov_.attitude_covariance[1]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[23] = cur_ins_cov_.attitude_covariance[2]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[27] = cur_ins_cov_.attitude_covariance[3]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[28] = cur_ins_cov_.attitude_covariance[4]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[29] = cur_ins_cov_.attitude_covariance[5]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[33] = cur_ins_cov_.attitude_covariance[6]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[34] = cur_ins_cov_.attitude_covariance[7]*degrees_square_to_radians_square;
			cur_odom_.pose.covariance[35] = cur_ins_cov_.attitude_covariance[8]*degrees_square_to_radians_square;

			cur_odom_.twist.covariance[0] = cur_ins_cov_.velocity_covariance[0];
			cur_odom_.twist.covariance[1] = cur_ins_cov_.velocity_covariance[1];
			cur_odom_.twist.covariance[2] = cur_ins_cov_.velocity_covariance[2];
			cur_odom_.twist.covariance[6] = cur_ins_cov_.velocity_covariance[3];
			cur_odom_.twist.covariance[7] = cur_ins_cov_.velocity_covariance[4];
			cur_odom_.twist.covariance[8] = cur_ins_cov_.velocity_covariance[5];
			cur_odom_.twist.covariance[12] = cur_ins_cov_.velocity_covariance[6];
			cur_odom_.twist.covariance[13] = cur_ins_cov_.velocity_covariance[7];
			cur_odom_.twist.covariance[14] = cur_ins_cov_.velocity_covariance[8];
		//}

//		if (got_ins_cov == false)
//			ROS_INFO_ONCE("NO INSCOV DATA.");
//		else
//		{
//
//			// Since, the data is being captured at high rate, there is a very little chance
//			// that the gps second headers of INSCOV and INSPVA match.
//
//			switch(count)
//			{
//			case 0:
//				cur_odom_.pose.covariance[0] = cur_ins_cov_.position_covariance[0];
//				cur_odom_.pose.covariance[1] = cur_ins_cov_.position_covariance[1];
//				cur_odom_.pose.covariance[2] = cur_ins_cov_.position_covariance[2];
//				cur_odom_.pose.covariance[6] = cur_ins_cov_.position_covariance[3];
//				cur_odom_.pose.covariance[7] = cur_ins_cov_.position_covariance[4];
//				cur_odom_.pose.covariance[8] = cur_ins_cov_.position_covariance[5];
//				cur_odom_.pose.covariance[12] = cur_ins_cov_.position_covariance[6];
//				cur_odom_.pose.covariance[13] = cur_ins_cov_.position_covariance[7];
//				cur_odom_.pose.covariance[14] = cur_ins_cov_.position_covariance[8];
//				count = 1;
//				ROS_INFO_ONCE("Position Covariances Added to Map Odometry.");
//				break;
//			case 1:
//				cur_odom_.pose.covariance[21] = cur_ins_cov_.attitude_covariance[0]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[22] = cur_ins_cov_.attitude_covariance[1]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[23] = cur_ins_cov_.attitude_covariance[2]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[27] = cur_ins_cov_.attitude_covariance[3]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[28] = cur_ins_cov_.attitude_covariance[4]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[29] = cur_ins_cov_.attitude_covariance[5]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[33] = cur_ins_cov_.attitude_covariance[6]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[34] = cur_ins_cov_.attitude_covariance[7]*degrees_square_to_radians_square;
//				cur_odom_.pose.covariance[35] = cur_ins_cov_.attitude_covariance[8]*degrees_square_to_radians_square;
//				count = 2;
//				ROS_INFO_ONCE("Attitude Covariances Added to Map Odometry.");
//				break;
//			case 2:
//				cur_odom_.twist.covariance[0] = cur_ins_cov_.velocity_covariance[0];
//				cur_odom_.twist.covariance[1] = cur_ins_cov_.velocity_covariance[1];
//				cur_odom_.twist.covariance[2] = cur_ins_cov_.velocity_covariance[2];
//				cur_odom_.twist.covariance[6] = cur_ins_cov_.velocity_covariance[3];
//				cur_odom_.twist.covariance[7] = cur_ins_cov_.velocity_covariance[4];
//				cur_odom_.twist.covariance[8] = cur_ins_cov_.velocity_covariance[5];
//				cur_odom_.twist.covariance[12] = cur_ins_cov_.velocity_covariance[6];
//				cur_odom_.twist.covariance[13] = cur_ins_cov_.velocity_covariance[7];
//				cur_odom_.twist.covariance[14] = cur_ins_cov_.velocity_covariance[8];
//				count = 0;
//				ROS_INFO_ONCE("Velocity Covariances Added to Map Odometry.");
//				break;
//			default:
//				count = 0;
//				break;
//			}
//		}
		odom_map_publisher_.publish(cur_odom_);
	}

	void RawImuHandler(RawImuShort &imu, double &timestamp) {
	}

	void InsCovHandler(InsCovariance &cov, double &timestamp) {
		cur_ins_cov_ = cov;
		got_ins_cov = 1;
	}
	// TB: Added to get g-corrected rates and accelerations from SPAN unit
	void CorrImuHandler(CorrImu &corrimu, double &timestamp) {
		static double span_scale_factor = 125.0;// For Span-IGM-S1

		sensor_msgs::Imu imu_msg;
		imu_msg.header.stamp = ros::Time::now();
		imu_msg.header.frame_id = "imu";

		/*
		 * In this IMU message roll, pitch, azimuth and course track
		 * angles are reported as they are measured by the SPAN in the vehicle frame.
		 * These are purely for the debugging purposes, and this sentence
		 * must not be used for orientation in any other node. Rather, only
		 * angular rates and acceleration data is useful in this sentence.
		 */

		geometry_msgs::Quaternion enu_orientation =
				tf::createQuaternionMsgFromRollPitchYaw(
						cur_inspva_.roll * degrees_to_radians,
						-cur_inspva_.pitch * degrees_to_radians,
						psi2theta(cur_inspva_.azimuth * degrees_to_radians));

		imu_msg.orientation = enu_orientation;

		/*
		 * X axis is East in ENU Frame and Forward in Body Frame is aligned with negative Y-axis on SPAN-IGM-S1 enclosure.
		 * Y-axis is North in ENU Frame and Left in Body Frame is aligned with X-axis on SPAN-IGM-S1 enclosure.
		 * Z-axis is Up in ENU Frame and Up in Body Frame is aligned with Z-axis on SPAN-IGM-S1 enclosure.
		 */
		imu_msg.angular_velocity.x = corrimu.roll_rate*span_scale_factor;
		imu_msg.angular_velocity.y = -corrimu.pitch_rate*span_scale_factor;
		imu_msg.angular_velocity.z = corrimu.yaw_rate*span_scale_factor;
		/*
		 *     Be careful with acceleration data.
		 *     The state estimation nodes in robot_localization assume that an IMU that is placed in
		 *     its neutral right-side-up position on a flat surface will:
		 *     Measure +9.81 meters per second squared for the Z-axis.
		 *     If the sensor is rolled +90 degrees (left side up), the acceleration should be +9.81 meters per second squared for the Y-axis.
		 *     If the sensor is pitched +90 degrees (front side down), it should read -9.81 meters per second squared for the X axis.
		 */
		imu_msg.linear_acceleration.x = corrimu.long_acceleration*span_scale_factor;
		imu_msg.linear_acceleration.y = -corrimu.lat_acceleration*span_scale_factor;
		imu_msg.linear_acceleration.z = corrimu.vertical_acceleration*span_scale_factor;
		/*
		 * Since SPAN is not publishing any covariances for rates and accelerations.
		 * So, based on captured data, a raw estimate of covariances are added
		 * to the code. Since, each sensor is separately measuring rate or acceleration,
		 * the cross terms can be set to zero, safely.
		 */
		if (cur_inspva_.status == INS_SOLUTION_GOOD)
		{
			imu_msg.orientation_covariance[0] = cur_ins_cov_.attitude_covariance[0]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[1] = cur_ins_cov_.attitude_covariance[1]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[2] = cur_ins_cov_.attitude_covariance[2]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[3] = cur_ins_cov_.attitude_covariance[3]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[4] = cur_ins_cov_.attitude_covariance[4]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[5] = cur_ins_cov_.attitude_covariance[5]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[6] = cur_ins_cov_.attitude_covariance[6]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[7] = cur_ins_cov_.attitude_covariance[7]*degrees_square_to_radians_square;
			imu_msg.orientation_covariance[8] = cur_ins_cov_.attitude_covariance[8]*degrees_square_to_radians_square;

			imu_msg.angular_velocity_covariance[0] = 2.5*degrees_square_to_radians_square;
			imu_msg.angular_velocity_covariance[4] = 2.5*degrees_square_to_radians_square;
			imu_msg.angular_velocity_covariance[8] = 2.5*degrees_square_to_radians_square;

			imu_msg.linear_acceleration_covariance[0] = 0.5;
			imu_msg.linear_acceleration_covariance[4] = 0.5;
			imu_msg.linear_acceleration_covariance[8] = 0.5;
		}
		else
		{
			imu_msg.orientation_covariance[0] = -1; // Safety: This will disable orientation usage in EKF nodes.
			imu_msg.angular_velocity_covariance[0] = -1;
			imu_msg.linear_acceleration_covariance[0] = -1;
		}

		//imu_msg._orientation_covariance_type
		imu_publisher_.publish(imu_msg);
	}

	void HardwareStatusHandler(ReceiverHardwareStatus &status,
			double &timestamp) {
	}

	void EphemerisHandler(GpsEphemeris &ephem, double &timestamp) {
		cur_ephem_.header.stamp = ros::Time::now();
		cur_ephem_.gps_time = ephem.header.gps_millisecs * 1000;
		cur_ephem_.obs = 1;
		uint8_t n = ephem.prn; // how drtk expects it
		cur_ephem_.prn[n] = ephem.prn;
		cur_ephem_.health[n] = ephem.health;
		cur_ephem_.semimajor_axis[n] = ephem.semi_major_axis; // this value is A, not the sqrt of A
		cur_ephem_.mean_anomaly[n] = ephem.anomoly_reference_time;
		cur_ephem_.eccentricity[n] = ephem.eccentricity;
		cur_ephem_.perigee_arg[n] = ephem.omega;
		cur_ephem_.cos_latitude[n] = ephem.latitude_cosine;
		cur_ephem_.sin_latitude[n] = ephem.latitude_sine;
		cur_ephem_.cos_orbit_radius[n] = ephem.orbit_radius_cosine;
		cur_ephem_.sin_orbit_radius[n] = ephem.orbit_radius_sine;
		cur_ephem_.cos_inclination[n] = ephem.inclination_cosine;
		cur_ephem_.sin_inclination[n] = ephem.inclination_sine;
		cur_ephem_.inclination_angle[n] = ephem.inclination_angle;
		cur_ephem_.right_ascension[n] = ephem.right_ascension;
		cur_ephem_.mean_motion_diff[n] = ephem.mean_motion_difference;
		cur_ephem_.inclination_rate[n] = ephem.inclination_angle_rate;
		cur_ephem_.ascension_rate[n] = ephem.right_ascension_rate;
		cur_ephem_.time_of_week[n] = ephem.time_of_week;
		cur_ephem_.reference_time[n] = ephem.time_of_ephemeris;
		cur_ephem_.clock_correction[n] = ephem.sv_clock_correction;
		cur_ephem_.group_delay[n] = ephem.group_delay_difference;
		cur_ephem_.clock_aging_1[n] = ephem.clock_aligning_param_0;
		cur_ephem_.clock_aging_2[n] = ephem.clock_aligning_param_1;
		cur_ephem_.clock_aging_3[n] = ephem.clock_aligning_param_2;

		ephemeris_publisher_.publish(cur_ephem_);
	}

	void CompressedRangeHandler(CompressedRangeMeasurements &range,
			double &timestamp) {
		gps_msgs::L1L2Range cur_range_;
		cur_range_.header.stamp = ros::Time::now();
		cur_range_.gps_time = range.header.gps_millisecs;
		uint8_t L1_obs = 0, L2_obs = 0;
		cur_range_.num_obs = range.number_of_observations;

		for (int n = 0; n < range.number_of_observations; n++) { //! FIXME how far should this iterate?
			// printf("%i ",n);
			// make sure something on this index & it is a GPS constellation SV
			if ((!range.range_data[n].range_record.satellite_prn) // empty field
					|| (range.range_data[n].channel_status.satellite_sys != 0) // critical
					|| (range.range_data[n].range_record.satellite_prn > 33) // critical
			) {
				continue;
			}

			uint8_t prn_idx = range.range_data[n].range_record.satellite_prn;
			switch (range.range_data[n].channel_status.signal_type) {
			case 0: // L1 C/A
				cur_range_.L1.prn[prn_idx] = prn_idx;
				cur_range_.L1.psr[prn_idx] =
						range.range_data[n].range_record.pseudorange / 128.;
				cur_range_.L1.psr_std[prn_idx] =
						range.range_data[n].range_record.pseudorange_standard_deviation; // FIXME scale factor?
				cur_range_.L1.carrier.doppler[prn_idx] =
						range.range_data[n].range_record.doppler / 256.;
				cur_range_.L1.carrier.noise[prn_idx] =
						range.range_data[n].range_record.carrier_to_noise + 20.;
				cur_range_.L1.carrier.phase[prn_idx] =
						-range.range_data[n].range_record.accumulated_doppler
						/ 256.; // negative sign is critical!!!
				cur_range_.L1.carrier.phase_std[prn_idx] =
						range.range_data[n].range_record.accumulated_doppler_std_deviation; // FIXME scale factor?
				L1_obs++;
				break;
			case 5: // L2 P
			case 9: // L2 P codeless
			case 17: // L2 C
				cur_range_.L2.prn[prn_idx] = prn_idx;
				cur_range_.L2.psr[prn_idx] = range.range_data[n].range_record.pseudorange / 128.;
				cur_range_.L2.psr_std[prn_idx] = range.range_data[n].range_record.pseudorange_standard_deviation; // FIXME scale factor?
				cur_range_.L2.carrier.doppler[prn_idx] = range.range_data[n].range_record.doppler / 256.;
				cur_range_.L2.carrier.noise[prn_idx] = range.range_data[n].range_record.carrier_to_noise + 20.;
				cur_range_.L2.carrier.phase[prn_idx] = -range.range_data[n].range_record.accumulated_doppler
						/ 256.; // negative sign is critical!!!
				cur_range_.L2.carrier.phase_std[prn_idx] = range.range_data[n].range_record.accumulated_doppler_std_deviation; // FIXME scale factor?
				L2_obs++;
				break;
			default:
				ROS_INFO_STREAM(name_ << ": L1L2RangeHandler: Unhandled signal type " << range.range_data[n].channel_status.signal_type);
				break;
			}
		}

		cur_range_.L1.obs = L1_obs;
		cur_range_.L2.obs = L2_obs;
		// change this to be populated by bestpos
		cur_range_.lat = cur_psrpos_.latitude;
		cur_range_.lon = cur_psrpos_.longitude;
		cur_range_.alt = cur_psrpos_.height;
		// !FIXME - convert these codes to actual values and populate fields
		// cur_range_.lat_cov = pow(cur_psr_lla_std_[0], 2);
		// cur_range_.lon_cov = pow(cur_psr_lla_std_[1], 2);
		// cur_range_.alt_cov = pow(cur_psr_lla_std_[2], 2);

		dual_band_range_publisher_.publish(cur_range_);
	}

	void PsrPosHandler(Position &pos, double &timestamp) {
		cur_psrpos_ = pos;

		sensor_msgs::NavSatFix sat_fix;

		switch(pos.position_type){
		case SINGLE:
			ROS_INFO_ONCE("PSRPOS: Position Type is SINGLE.");
			break;
		case PSRDIFF:
			ROS_INFO_ONCE("PSRPOS: Position Type is PSRDIFF.");
			break;
		case NARROW_FLOAT:
			ROS_INFO_ONCE("PSRPOS: Position Type is NARROW_FLOAT.");
			break;
		case L1_INT:
			ROS_INFO_ONCE("PSRPOS: Position Type is L1_INT.");
			break;
		case WIDE_INT:
			ROS_INFO_ONCE("PSRPOS: Position Type is WIDE_INT.");
			break;
		case NARROW_INT:
			ROS_INFO_ONCE("PSRPOS: Position Type is NARROW_INT.");
			break;
		case RTK_DIRECT_INS:
			ROS_INFO_ONCE("PSRPOS: Position Type is RTK_DIRECT_INS.");
			break;
		case INS_PSRDIFF:
			ROS_INFO_ONCE("PSRPOS: Position Type is INS_PSRDIFF.");
			break;
		case INS_RTKFLOAT:
			ROS_INFO_ONCE("PSRPOS: Position Type is INS_RTKFLOAT.");
			break;
		case INS_RTKFIXED:
			ROS_INFO_ONCE("PSRPOS: Position Type is INS_RTKFIXED.");
			break;
		default:
			ROS_INFO_ONCE("PSRPOS: Position Type is UNKNOWN.");
			break;
		}

		if (pos.position_type == NONE)
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_NO_FIX;
		else if ((pos.position_type == WAAS) || (pos.position_type == OMNISTAR)
				|| (pos.position_type == OMNISTAR_HP)
				|| (pos.position_type == OMNISTAR_XP)
				|| (pos.position_type == CDGPS))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_SBAS_FIX;
		else if ((pos.position_type == PSRDIFF)
				|| (pos.position_type == NARROW_FLOAT)
				|| (pos.position_type == L1_INT)
				|| (pos.position_type == WIDE_INT)
				|| (pos.position_type == NARROW_INT)
				|| (pos.position_type == RTK_DIRECT_INS)
				|| (pos.position_type == INS_PSRDIFF)
				|| (pos.position_type == INS_RTKFLOAT)
				|| (pos.position_type == INS_RTKFIXED))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_GBAS_FIX;
		else
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_FIX;

		if (pos.signals_used_mask & 0x30)
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GLONASS;
		else
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GPS;

		sat_fix.header.stamp = ros::Time::now();
		sat_fix.header.frame_id = "/pseudo";
		sat_fix.latitude = pos.latitude;
		sat_fix.longitude = pos.longitude;
		sat_fix.altitude = pos.height;

		sat_fix.position_covariance[0] = pow( pos.latitude_standard_deviation, 2);
		sat_fix.position_covariance[4] = pow( pos.longitude_standard_deviation, 2);
		sat_fix.position_covariance[8] = pow( pos.height_standard_deviation, 2);
		/*TB: For debugging purposes. */
		sat_fix.position_covariance[1] = pos.differential_age;
		sat_fix.position_covariance[2] = pos.solution_age;
		sat_fix.position_covariance[3] = pos.position_type;
		sat_fix.position_covariance[5] = pos.number_of_satellites;
		psrpos_publisher_.publish(sat_fix);
	}

	void BESTGNSSPosHandler(Position &pos, double &timestamp) {
		cur_bestgnsspos_ = pos;
		double northing, easting;
		int zoneNum;
		bool north;

		sensor_msgs::NavSatFix sat_fix;

		switch(pos.position_type){
		case SINGLE:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is SINGLE.");
			break;
		case PSRDIFF:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is PSRDIFF.");
			break;
		case NARROW_FLOAT:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is NARROW_FLOAT.");
			break;
		case L1_INT:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is L1_INT.");
			break;
		case WIDE_INT:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is WIDE_INT.");
			break;
		case NARROW_INT:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is NARROW_INT.");
			break;
		case RTK_DIRECT_INS:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is RTK_DIRECT_INS.");
			break;
		case INS_PSRDIFF:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is INS_PSRDIFF.");
			break;
		case INS_RTKFLOAT:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is INS_RTKFLOAT.");
			break;
		case INS_RTKFIXED:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is INS_RTKFIXED.");
			break;
		default:
			ROS_INFO_ONCE("BESTGNSSPOS: Position Type is UNKNOWN.");
			break;
		}

		if (pos.position_type == NONE)
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_NO_FIX;
		else if ((pos.position_type == WAAS) || (pos.position_type == OMNISTAR)
				|| (pos.position_type == OMNISTAR_HP)
				|| (pos.position_type == OMNISTAR_XP)
				|| (pos.position_type == CDGPS))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_SBAS_FIX;
		else if ((pos.position_type == PSRDIFF)
				|| (pos.position_type == NARROW_FLOAT)
				|| (pos.position_type == L1_INT)
				|| (pos.position_type == WIDE_INT)
				|| (pos.position_type == NARROW_INT)
				|| (pos.position_type == RTK_DIRECT_INS)
				|| (pos.position_type == INS_PSRDIFF)
				|| (pos.position_type == INS_RTKFLOAT)
				|| (pos.position_type == INS_RTKFIXED))
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_GBAS_FIX;
		else
			sat_fix.status.status = sensor_msgs::NavSatStatus::STATUS_FIX;

		if (pos.signals_used_mask & 0x30)
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GLONASS;
		else
			sat_fix.status.service = sensor_msgs::NavSatStatus::SERVICE_GPS;

		sat_fix.header.stamp = ros::Time::now();
		sat_fix.header.frame_id = "/gnss";
		sat_fix.latitude = pos.latitude;
		sat_fix.longitude = pos.longitude;
		sat_fix.altitude = pos.height;

		sat_fix.position_covariance[0] = pow( pos.latitude_standard_deviation, 2);
		sat_fix.position_covariance[4] = pow( pos.longitude_standard_deviation, 2);
		sat_fix.position_covariance[8] = pow( pos.height_standard_deviation, 2);
		/*TB: For debugging purposes. */
		sat_fix.position_covariance[1] = pos.differential_age;
		sat_fix.position_covariance[2] = pos.solution_age;
		sat_fix.position_covariance[3] = pos.position_type;
		sat_fix.position_covariance[5] = pos.number_of_satellites;
		//bestgnsspos_publisher_.publish(sat_fix);
		bestpos_publisher_.publish(sat_fix);

		// This is then used to create an odometry sentence.
		gps_.ConvertLLaUTM(pos.latitude, pos.longitude, &northing,
				&easting, &zoneNum, &north);

		// This sentences.
		nav_msgs::Odometry cur_odom_;
		cur_odom_.header.stamp = ros::Time::now();
		cur_odom_.header.frame_id = "odom";
		cur_odom_.child_frame_id = "base_link";

		cur_odom_.pose.pose.position.x = easting;
		cur_odom_.pose.pose.position.y = northing;
		cur_odom_.pose.pose.position.z = pos.height;
		// covariance representation given in REP 103
		//http://www.ros.org/reps/rep-0103.html#covariance-representation
		// (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
		// row major
		cur_odom_.pose.covariance[0] = pos.latitude_standard_deviation*pos.latitude_standard_deviation;
		cur_odom_.pose.covariance[7] = pos.longitude_standard_deviation*pos.longitude_standard_deviation;
		cur_odom_.pose.covariance[14] = pos.height_standard_deviation*pos.height_standard_deviation;
		// have no way of knowing roll and pitch with just GPS
		cur_odom_.pose.covariance[21] = DBL_MAX;
		cur_odom_.pose.covariance[28] = DBL_MAX;
		// embed lever arms information in this sentence
		/* TB: add critical information in this topic for debugging -- */
		cur_odom_.pose.covariance[15] = pos.solution_status;
		cur_odom_.pose.covariance[16] = pos.position_type;
		cur_odom_.pose.covariance[17] = pos.undulation;
		cur_odom_.pose.covariance[18] = pos.datum_id;
		cur_odom_.pose.covariance[19] = pos.base_station_id[0];
		cur_odom_.pose.covariance[20] = pos.base_station_id[1];
		cur_odom_.pose.covariance[22] = pos.base_station_id[2];
		cur_odom_.pose.covariance[23] = pos.base_station_id[3];
		cur_odom_.pose.covariance[24] = pos.differential_age;
		cur_odom_.pose.covariance[25] = pos.solution_age;
		cur_odom_.pose.covariance[26] = pos.number_of_satellites;
		cur_odom_.pose.covariance[27] = pos.number_of_satellites_in_solution;
		cur_odom_.pose.covariance[29] = pos.extended_solution_status;

		/*TB: Do not need to check the GPS time stamps in BESTPOS and BESTVEL*/
		/*if ((cur_velocity_.header.gps_week == pos.header.gps_week)
						&& (cur_velocity_.header.gps_millisecs
								== pos.header.gps_millisecs))*/
		{
			//ROS_INFO_ONCE("BESTVEL FUSED WITH BESTUTM.");
			cur_odom_.twist.twist.linear.x = cur_velocity_.horizontal_speed*sin(cur_velocity_.track_over_ground * degrees_to_radians);
			cur_odom_.twist.twist.linear.y = cur_velocity_.horizontal_speed*cos(cur_velocity_.track_over_ground * degrees_to_radians);
			cur_odom_.twist.twist.linear.z = cur_velocity_.vertical_speed;

			cur_odom_.pose.pose.orientation = tf::createQuaternionMsgFromYaw(
					psi2theta(cur_velocity_.track_over_ground*degrees_to_radians));

			// if i have a fix, velocity std, dev is constant
			if (cur_velocity_.position_type > NONE)
			{
				// yaw covariance
				double heading_std_dev = sigma_v / cur_velocity_.horizontal_speed;
				cur_odom_.pose.covariance[35] = heading_std_dev * heading_std_dev;
				// x and y velocity covariance
				cur_odom_.twist.covariance[0] = sigma_v * sigma_v;
				cur_odom_.twist.covariance[7] = sigma_v * sigma_v;
			}
			else
			{
				cur_odom_.pose.covariance[35] = DBL_MAX;
				cur_odom_.twist.covariance[0] = DBL_MAX;
				cur_odom_.twist.covariance[7] = DBL_MAX;
			}
		}
		odom_base_publisher_.publish(cur_odom_);

	}

	void BestPositionEcefHandler(PositionEcef &best_xyz, double timestamp) {
		nav_msgs::Odometry ecef_pos;

		ecef_pos.header.stamp = ros::Time::now();
		ecef_pos.header.frame_id = "/ecef";

		ecef_pos.pose.pose.position.x = best_xyz.x_position;
		ecef_pos.pose.pose.position.y = best_xyz.y_position;
		ecef_pos.pose.pose.position.z = best_xyz.z_position;

		ecef_pos.pose.covariance[1] = pow(best_xyz.x_standard_deviation, 2);
		ecef_pos.pose.covariance[8] = pow(best_xyz.y_standard_deviation, 2);
		ecef_pos.pose.covariance[15] = pow(best_xyz.z_standard_deviation, 2);

		ecef_pos.twist.twist.linear.x = best_xyz.x_velocity;
		ecef_pos.twist.twist.linear.y = best_xyz.y_velocity;
		ecef_pos.twist.twist.linear.z = best_xyz.z_velocity;

		ecef_pos.twist.covariance[1] = pow(best_xyz.x_velocity_standard_deviation, 2);
		ecef_pos.twist.covariance[8] = pow(best_xyz.y_velocity_standard_deviation, 2);
		ecef_pos.twist.covariance[15] = pow(best_xyz.z_velocity_standard_deviation, 2);

		ecefpos_publisher_.publish(ecef_pos);
	}

	void RawMsgHandler(unsigned char *msg) {
		// ROS_INFO_STREAM("RAW RANGE MSG\n\tsizeof: " << sizeof(msg));
	}

	void BestLeverArmHandler(BestLeverArm &lever_arm, double timestamp) {
		cur_bestleverarm_ = lever_arm;
		ROS_INFO_STREAM(
				"IMU to antenna offset (in meters):\n\t" << "x: " <<
				lever_arm.x_offset << " (uncertainty: " << lever_arm.x_uncertainty
				<< ")\n\t" << "y: " << lever_arm.y_offset <<
				" (uncertainty: " << lever_arm.y_uncertainty << ")\n\t"
				<< "z: " << lever_arm.z_offset << " (uncertainty: " <<
				lever_arm.z_uncertainty << ")\n\t");
	}

	void run() {

		if (!this->getParameters())
			return;

		this->odom_base_publisher_ = nh_.advertise<nav_msgs::Odometry>(odom_base_topic_, 10); // bestutm
		this->nav_sat_fix_publisher_ = nh_.advertise<sensor_msgs::NavSatFix>(nav_sat_fix_topic_, 10); // inspva
		this->bestpos_publisher_ = nh_.advertise<sensor_msgs::NavSatFix>(bestpos_topic_, 10); // bestpos
		this->imu_publisher_ = nh_.advertise<sensor_msgs::Imu>(imu_topic_, 10); // corrimu
		this->odom_map_publisher_ = nh_.advertise<nav_msgs::Odometry>(odom_map_topic_, 10); // inspva
		// ! FIXME - only advertise ephem/range if going to publish it.
		this->ephemeris_publisher_ = nh_.advertise<gps_msgs::Ephemeris>(ephemeris_topic_,10); // gpsephem
		this->dual_band_range_publisher_ = nh_.advertise<gps_msgs::L1L2Range>(dual_band_range_topic_,10); // rangecmp
		this->psrpos_publisher_ = nh_.advertise<sensor_msgs::NavSatFix>(psrpos_topic_,10); // psrpos
		this->bestgnsspos_publisher_ = nh_.advertise<sensor_msgs::NavSatFix>(bestgnsspos_topic_,10); // bestgnsspos

		// this->ecefpos_publisher_ = nh_.advertise<nav_msgs::Odometry>(ecefpos_topic_, 0);
		//em_.setDataCallback(boost::bind(&EM61Node::HandleEmData, this, _1));
		gps_.Connect(gps_port_, gps_baudrate_, 0); // no need to search for other baud rates and ping for receiver.
		//span_.Connect(span_port_, span_baudrate_, 0);

		// configure lever arms
		if (lever_arms_ != "") {
			// string should contain com_port,baud_rate,rx_mode,tx_mode
			// parse message body by tokening on ","
			typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
			boost::char_separator<char> sep(",");
			tokenizer tokens(lever_arms_, sep);
			// set up iterator to go through token list
			tokenizer::iterator current_token = tokens.begin();
			std::string num_comps_string = *(current_token);
			int number_components = atoi(num_comps_string.c_str());
			// make sure the correct number of tokens were found
			int token_count = 0;
			for (current_token = tokens.begin(); current_token != tokens.end();
					++current_token) {
				token_count++;
			}

			if (token_count != 3) {
				ROS_ERROR_STREAM("Incorrect number of tokens in lever arm value: " << lever_arms_);
			} else {
				current_token = tokens.begin();
				std::string xoff = *(current_token++);
				std::string yoff = *(current_token++);
				std::string zoff = *(current_token++);

				ROS_INFO_STREAM("Sending lever arm values. ");
				gps_.ConfigureLeverArm(xoff, yoff, zoff);
			}
		}

		// configure default log sets
		if (span_default_logs_period_ > 0) {
			ROS_INFO("Requesting SPAN messages: INSPVAB, CORRIMUDATAB, INSCOVB");
			std::stringstream default_logs;
			default_logs.precision(2);
			default_logs << "INSPVAB ONTIME " << std::fixed << span_default_logs_period_ << ";";
			default_logs << "CORRIMUDATAB ONTIME " << std::fixed << span_default_logs_period_<<";" ;
			//default_logs << "INSCOVB ONTIME 0" ;//<< std::fixed << gps_default_logs_period_ ;
			//ROS_INFO_STREAM("default logs: " << default_logs);
			gps_.ConfigureLogs(default_logs.str());
		}

		if (gps_default_logs_period_ > 0) {
			ROS_INFO("Requesting default GPS messages: BESTPOSB, BESTVELB");
			std::stringstream default_logs;
			default_logs.precision(2);
			default_logs << "BESTPOSB ONTIME " << std::fixed << gps_default_logs_period_ << ";";
			default_logs << "BESTVELB ONTIME " << std::fixed << gps_default_logs_period_ << ";";
			gps_.ConfigureLogs(default_logs.str());
		}

		if (bestgnsspos_default_logs_period_ > 0) {
			ROS_INFO("Requesting default GPS messages: BESTGNSSPOSB, BESTGNSSVELB");
			std::stringstream default_logs;
			default_logs.precision(2);
			default_logs << "BESTGNSSPOSB ONTIME " << std::fixed << bestgnsspos_default_logs_period_ << ";";
			default_logs << "BESTGNSSVELB ONTIME " << std::fixed << bestgnsspos_default_logs_period_ << ";";
			gps_.ConfigureLogs(default_logs.str());
		}

		if (!ephem_log_.empty()) {
			std::stringstream default_logs;
			default_logs << "GPSEPHEMB " << std::fixed << ephem_log_;
			gps_.ConfigureLogs(default_logs.str());
		}

		if (range_default_logs_period_ > 0) {
			std::stringstream default_logs;
			default_logs.precision(2);
			default_logs << "RANGECMPB ONTIME " << std::fixed
					<< range_default_logs_period_ << ";";
			gps_.ConfigureLogs(default_logs.str());
		}

		if (psrpos_default_logs_period_ > 0) {
			std::stringstream default_logs;
			default_logs.precision(2);
			default_logs << "PSRPOSB ONTIME " << std::fixed
					<< psrpos_default_logs_period_ << ";";
			gps_.ConfigureLogs(default_logs.str());
		}


		// configure additional logs
		gps_.ConfigureLogs(log_commands_);

		// configure serial port for input corrections
		if (configure_port_ != "") {
			// string should contain com_port,baud_rate,rx_mode,tx_mode
			// parse message body by tokening on ","
			typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
			boost::char_separator<char> sep(",");
			tokenizer tokens(configure_port_, sep);
			// set up iterator to go through token list
			tokenizer::iterator current_token = tokens.begin();
			std::string num_comps_string = *(current_token);
			int number_components = atoi(num_comps_string.c_str());
			// make sure the correct number of tokens were found
			int token_count = 0;
			for (current_token = tokens.begin(); current_token != tokens.end();
					++current_token) {
				token_count++;
			}

			if (token_count != 4) {
				ROS_ERROR_STREAM("Incorrect number of tokens in configure port parameter: " << configure_port_);
			} else {
				current_token = tokens.begin();
				std::string com_port = *(current_token++);
				int baudrate = atoi((current_token++)->c_str());
				std::string rx_mode = *(current_token++);
				std::string tx_mode = *(current_token++);

				ROS_INFO_STREAM("Configure com port baud rate and interface mode for " << com_port << ".");
				gps_.ConfigureInterfaceMode(com_port, rx_mode, tx_mode);
				gps_.ConfigureBaudRate(com_port, baudrate);
				gps_.ConfigureLogs(gpgga_log_command_);
			}
		}

		ros::spin();

		//ros::Rate loop_rate(1); // Replace 10 with your desired loop rate in Hz

		//while (ros::ok()) {
			//

			//ros::spinOnce(); // Process any incoming callbacks

			//loop_rate.sleep(); // Sleep to achieve the desired loop rate
		//}
	} // function

protected:

	void disconnect() {
		//em_.stopReading();
		//em_.disconnect();
		gps_.SendCommand("UNLOGALL");
		//span_.SendCommand("UNLOGALL");
		//span_.SendCommand("UNLOGALL COM2");
	}

	bool getParameters() {

		name_ = ros::this_node::getName();

		nh_.param("odom_base_topic", odom_base_topic_, std::string("/odom_gps"));
		ROS_INFO_STREAM(name_ << ": Base Odom Topic: " << odom_base_topic_);

		nh_.param("nav_sat_fix_topic", nav_sat_fix_topic_, std::string("/gps_fix"));
		ROS_INFO_STREAM(name_ << ": NavSatFix Topic: " << nav_sat_fix_topic_);

		nh_.param("bestpos_topic", bestpos_topic_, std::string("/bestpos"));
		ROS_INFO_STREAM(name_ << ": Bestpos Topic: " << bestpos_topic_);

		nh_.param("psrpos_topic", psrpos_topic_, std::string("/gps_fix_psr"));
		ROS_INFO_STREAM(name_ << ": Pseudorange Position Topic: " << psrpos_topic_);

		nh_.param("bestgnsspos_topic", bestgnsspos_topic_, std::string("/gps_fix_gnss"));
		ROS_INFO_STREAM(name_ << ": Best GNSS Position Topic: " << bestgnsspos_topic_);

		nh_.param("ecefpos_topic", ecefpos_topic_, std::string("/gps_fix_ecef"));
		ROS_INFO_STREAM(name_ << ": ECEF Position Topic: " << ecefpos_topic_);

		nh_.param("imu_topic", imu_topic_, std::string("/imu"));
		ROS_INFO_STREAM(name_ << ": Corr IMU Topic: " << imu_topic_);

		nh_.param("odom_map_topic", odom_map_topic_, std::string("/odom/map"));
		ROS_INFO_STREAM(name_ << ": Map Odom Topic: " << odom_map_topic_);

		nh_.param("ephemeris_topic", ephemeris_topic_, std::string("/ephemeris"));
		ROS_INFO_STREAM(name_ << ": Ephemeris Topic: " << ephemeris_topic_);

		nh_.param("dual_band_range_topic", dual_band_range_topic_, std::string("/range"));
		ROS_INFO_STREAM( name_ << ": L1L2Range Topic: " << dual_band_range_topic_);


		//nh_.param("span_port", span_port_, std::string("/dev/ttyUSB0"));
		//ROS_INFO_STREAM(name_ << ": Port: " << span_port_);

		//nh_.param("span_baudrate", span_baudrate_, 115200);
		//ROS_INFO_STREAM(name_ << ": SPAN Baudrate: " << span_baudrate_);

		nh_.param("gps_port", gps_port_, std::string("/dev/ttyUSB3"));
		ROS_INFO_STREAM(name_ << ": GPS Port: " << gps_port_);

		nh_.param("gps_baudrate", gps_baudrate_, 115200);
		ROS_INFO_STREAM(name_ << ": GPS Baudrate: " << gps_baudrate_);

		nh_.param("log_commands", log_commands_, std::string(""));
		ROS_INFO_STREAM(name_ << ": Log Commands: " << log_commands_);

		nh_.param("gpgga_log_command", gpgga_log_command_, std::string("COM2 GPGGA ONTIME 1"));
		ROS_INFO_STREAM(name_ << ": GPGGA Log Command: " << gpgga_log_command_);

		nh_.param("configure_port", configure_port_, std::string(""));
		ROS_INFO_STREAM(name_ << ": Configure port: " << configure_port_);

		nh_.param("lever_arm", lever_arms_, std::string(""));
		ROS_INFO_STREAM(name_ << ": Lever arm values: " << lever_arms_);

		nh_.param("gps_default_logs_period", gps_default_logs_period_, 0.0);
		ROS_INFO_STREAM(name_ << ": Default GPS logs period: " << gps_default_logs_period_);

		nh_.param("span_default_logs_period", span_default_logs_period_, 0.0);
		ROS_INFO_STREAM(name_ << ": Default SPAN logs period: " << span_default_logs_period_);

		nh_.param("ephem_log", ephem_log_, std::string(""));
		if (!ephem_log_.empty())
			ROS_INFO_STREAM(name_ << ": Ephemeris logging enabled: " << ephem_log_);

		nh_.param("range_default_logs_period", range_default_logs_period_, 0.0);
		ROS_INFO_STREAM(name_ << ": Default Range logs period: " << range_default_logs_period_);

		nh_.param("psrpos_default_logs_period", psrpos_default_logs_period_, 0.0);
		ROS_INFO_STREAM(name_ << ": Default Pseudorange Position logs period: " << psrpos_default_logs_period_);

		nh_.param("bestgnsspos_default_logs_period", bestgnsspos_default_logs_period_, 0.0);
		ROS_INFO_STREAM(name_ << ": Default GNSS Position logs period: " << bestgnsspos_default_logs_period_);

		return true;
	}

	////////////////////////////////////////////////////////////////
	// ROSNODE Members
	////////////////////////////////////////////////////////////////
	ros::NodeHandle nh_;
	std::string name_;
	ros::Publisher odom_base_publisher_;
	ros::Publisher nav_sat_fix_publisher_;
	ros::Publisher bestpos_publisher_;
	ros::Publisher ephemeris_publisher_;
	ros::Publisher dual_band_range_publisher_;
	ros::Publisher psrpos_publisher_;
	ros::Publisher bestgnsspos_publisher_;
	ros::Publisher ecefpos_publisher_;
	ros::Publisher imu_publisher_;
	ros::Publisher odom_map_publisher_;

	ros::ServiceClient client;

	Novatel gps_;// span_; //

	// topics - why are we not using remap arguments?
	std::string odom_base_topic_;
	std::string nav_sat_fix_topic_;
	std::string bestpos_topic_;
	std::string ephemeris_topic_;
	std::string dual_band_range_topic_;
	std::string psrpos_topic_;
	std::string bestgnsspos_topic_;
	std::string ecefpos_topic_;
	std::string imu_topic_;
	std::string odom_map_topic_;

	//std::string span_port_;
	std::string gps_port_;

	std::string log_commands_;
	std::string lever_arms_;
	std::string gpgga_log_command_;
	std::string configure_port_;
	double gps_default_logs_period_;
	double span_default_logs_period_;
	double range_default_logs_period_;
	double psrpos_default_logs_period_;
	double bestgnsspos_default_logs_period_;
	std::string ephem_log_;

	int span_baudrate_;
	int gps_baudrate_;

	/*bool got_inspva;
	bool got_bestutm;
	bool got_bestvel;
	bool got_corr_imu;
	bool got_raw_imu;
	bool got_bestpos;*/
	double poll_rate_;
	bool got_ins_cov;

	Velocity cur_velocity_;
	//InsCovarianceShort cur_ins_cov_;
	gps_msgs::Ephemeris cur_ephem_;
	gps_msgs::L1L2Range cur_range_;
	InsCovariance cur_ins_cov_;
	Position cur_psrpos_;
	Position cur_bestgnsspos_;
	Position cur_bestpos_;
	UtmPosition cur_utm_bestpos_;
	InsPositionVelocityAttitude cur_inspva_;
	//InsPositionVelocityAttitudeShort cur_inspva_;
	BestLeverArm cur_bestleverarm_ ;
	// holders for data common to multiple messages
	// double cur_psr_lla_[3];
	// double cur_psr_lla_std_[3];
	// double cur_utm_[3];
	// double cur_utm_std_[3];

};
// end class NovatelNode

int main(int argc, char **argv) {
	ros::init(argc, argv, "novatel_node");

	NovatelNode node;
	//ros::service::waitForService("/datum");

	node.run();

	return 0;
}
